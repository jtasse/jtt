<!doctype html>
<html lang="en">
	<head>
		<script src="./docs-as-tests-part-ii-the-how.js"></script>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Docs as Tests: Part II ‚Äî The How - James.Tasse</title>
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="" />
		<link
			href="https://fonts.googleapis.com/css2?family=Nunito:ital,wght@0,200..1000;1,200..1000&amp;family=Helvetica:wght@400..900&amp;display=swap"
			rel="stylesheet"
		/>
		<link rel="stylesheet" href="/src/content/blog/blog.css" />
		<script src="/src/content/blog/blog.js" defer></script>

		<meta name="keywords" content="docs-as-tests" />
		<meta
			name="description"
			content="This is part two in a series of posts describing the value and implementation of Docs as Tests."
		/>
		<link
			rel="canonical"
			href="https://jamestasse.tech/blog/posts/docs-as-tests-part-ii-the-how.html"
		/>
		<link
			rel="image_src"
			href="/src/content/blog/nav-images/doc_engineer_wide.webp"
		/>
		<meta property="og:type" content="article" />
		<meta
			property="og:title"
			content="Docs as Tests: Part II ‚Äî The How - James.Tasse"
		/>
		<meta
			property="og:description"
			content="This is part two in a series of posts describing the value and implementation of Docs as Tests."
		/>
		<meta
			property="og:image"
			content="/src/content/blog/nav-images/doc_engineer_wide.webp"
		/>
		<meta
			property="og:url"
			content="https://jamestasse.tech/blog/posts/docs-as-tests-part-ii-the-how.html"
		/>
		<meta property="og:site_name" content="James Tasse" />
		<meta name="twitter:card" content="summary_large_image" />
		<meta
			name="twitter:title"
			content="Docs as Tests: Part II ‚Äî The How - James.Tasse"
		/>
		<meta
			name="twitter:description"
			content="This is part two in a series of posts describing the value and implementation of Docs as Tests."
		/>
		<meta
			name="twitter:image"
			content="/src/content/blog/nav-images/doc_engineer_wide.webp"
		/>
	</head>
	<body>
		<div id="content" class="container">
			<main class="blog-content single-post">
				<article>
					<div class="post-image">
						<img
							src="/src/content/blog/nav-images/doc_engineer_wide.webp"
							alt="Docs as Tests: Part II ‚Äî The How"
						/>
					</div>

					<h1>Docs as Tests: Part II‚ÄîThe How</h1>
					<div class="post-meta">
						<time datetime="2025-06-02">June 2, 2025</time> | James Tasse | 8
						min read
					</div>

					<blockquote>
						<p>
							This is part two in a series of posts describing the value and
							implementation of
							<a href="https://www.docsastests.com/">Docs as Tests</a>.
						</p>
					</blockquote>

					<!-- full article content pulled from live site -->
					<nav class="toc">
						<p class="toc-heading">Contents</p>
						<ol>
							<li>
								<a href="#previously-on-docs-as-tests"
									>Previously On Docs as Tests</a
								>
							</li>
							<li><a href="#intended-audience">Intended Audience</a></li>
							<li><a href="#technical-approach">Technical Approach</a></li>
							<li><a href="#goals-for-this-post">Goals for this post</a></li>
							<li><a href="#where-are-we">Where Are We?</a></li>
							<li><a href="#prerequisites">Prerequisites</a></li>
							<li>
								<a href="#structure-of-the-docsastests-demo-project"
									>Structure of the docsastests-demo project</a
								>
							</li>
							<li><a href="#running-the-tests">Running the tests</a></li>
							<li><a href="#what-now">What now?</a></li>
							<li><a href="#code coverage">Code Coverage</a></li>
						</ol>
					</nav>

					<p class="edit-note">
						<strong>EDIT June 30, 2025</strong>: I have created a
						<a
							href="https://www.youtube.com/watch?v=yu0_Xme9lEI"
							target="_blank"
							rel="noreferrer noopener"
							>companion video</a
						>
						that illustrates the points of this post (and more). Just want to
						see how to set up and run Docs as Tests? Use
						<a
							href="https://www.youtube.com/watch?v=yu0_Xme9lEI&amp;t=717s"
							target="_blank"
							rel="noreferrer noopener"
							>this link</a
						>
						to jump straight there.
					</p>
					<h2 id="previously-on-docs-as-tests"><a href="https://jamestasse.tech/blog/posts/docs-as-tests-on-a-high-level">Previously</a> on Docs as Tests</h2>
					<p>Previously on Docs as Tests</h2>
					<ul>
						<li>
							I described the promise of the <a href="https://www.docsastests.com/">Docs As Tests discipline</a> coined by
							<a href="https://www.linkedin.com/in/manuelrbsilva">Manny Silva</a> and borrowed liberally from Manny‚Äôs fantastic <a href="https://www.amazon.com/Docs-Tests-Resilient-Technical-Documentation/dp/0994169361">book</a> of
							the same name.
						</li>
						<li>
							I then went on to categorize some of the tools mentioned in the book
							before encouraging documentarians to start thinking about what
							part(s) of their environment might benefit the most from a Docs as
							Tests implementation.
						</li>
						<li>
							Finally, I presented a very simple <a href="./docs-as-tests-on-a-high-level#demo">demo</a> showing how Docs as Tests
							(and Manny‚Äôs Doc Detective tool, in this case) can catch a
							divergence between a product (a web application in this scenario)
							and the documentation intended to describe it.
						</li>
					</ul>
					<p>
						My last post was very much focused on the business value of Docs as
						Tests and [hopefully] building some excitement in the minds of
						technical writers. But in this one my goal is to provide enough
						technical detail to whet the appetite of more technical folks (think
						developers, DocOps, etc.) while still bringing along those of you
						tech writers (or documentarians, if you prefer) that dared to dream
						after seeing the demo from last time.
					</p>
					<section>
						<h2 id="intended-audience">Intended Audience</h2>
						<p>
							My last post was very much focused on the business value of Docs
							as Tests and [hopefully] building some excitement in the minds of
							technical writers. But in this one my goal is to provide enough
							technical detail to whet the appetite of more technical folks
							(think developers, DocOps, etc.) while still bringing along those
							of you tech writers (or documentarians, if you prefer) that dared
							to dream after seeing the demo from last time.
						</p>
						<blockquote>
							By the way, it's important I acknowledge that some documentarians
							write code and some software engineers write docs‚ÄîI will do my
							best to meet you where you are!
						</blockquote>
					</section>
					<section>
						<h2 id="technical-approach">Technical Approach</h2>
						<p>
							I fully admit that trying to create an instructional technical
							post for such a diverse set of readers is a bit like threading a
							needle, but I am going to try anyway. So I'll start with some
							suggestions as you read this post:
						</p>
						<ul>
							<li>
								<p>
									<strong>For folks with less technical experience</strong>:
									this might feel a bit like onboarding at your last job (but
									hopefully more fun!), as I am going to introduce you to the
									tools, commands, etc. that you'll need to run the demo from
									the
									<a href="/blog/posts/docs-as-tests-on-a-high-level"
										>last post</a
									>
									(and more) yourself. If at any point you feel overwhelmed,
									that‚Äôs fine‚Äîyou are welcome to
									<a href="mailto: james.tasse@gmail.com">email me</a> or take a
									break and come back in an hour, a day, or a week.
								</p>
							</li>
							<li>
								<p>
									<strong>For folks with more technical experience</strong>:
									I'll try to structure things so you can easily skip over
									sections you might already know (for example - installing VS
									Code).
								</p>
							</li>
							<li>
								<p>
									<strong>For everyone</strong>: if you need help or have
									questions/feedback regarding this post; go ahead and email me
									or leave a comment below. On the other hand, if your
									questions/feedback relate to Doc Detective, visit the Doc
									Detective
									<a href="https://discord.gg/2M7wXEThfF">Discord</a> or
									<a
										href="https://www.linkedin.com/company/doc-detective/posts/?feedView=all"
										>LinkedIn page</a
									>.
								</p>
							</li>
						</ul>
					</section>
					<section>
						<h2 id="goals-for-this-post">Goals for this post</h2>
						<ol>
							<li>
								Discuss where the testing we're doing fits with automated
								software tests
							</li>
							<li>Install prerequisites</li>
							<li>Run tests</li>
						</ol>
					</section>
					<section>
						<h2 id="where-are-we">Where Are We?</h2>
						<p>
							Before getting into the technical stuff I want to paint a picture
							of where Docs as Tests lives in the software development and
							documentation space. If you have any familiarity with Continuous
							Integration / Continuous Delivery (or
							<a href="https://about.gitlab.com/topics/ci-cd/">CI/CD</a>),
							you've probably seen a diagram like the one below.
						</p>
						<h3>CI/CD Diagram</h3>

						<img
							src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/dat2-cicd-diagram.png?w=1024"
							alt="CI/CD Diagram"
						/>

						<blockquote>
							<em
								>Image source:
								https://www.primotech.com/ci-cd-pipeline-everything-you-need-to-know/</em
							>
						</blockquote>
						<p>
							Basically, the software (and docs) development process goes from
							left to right . Now for our purposes, we want to focus on the test
							step.
						</p>
						<h3>CI/CD Diagram (test step)</h3>
						<img
							src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/dat2-cicd-diagram-test.png?w=1024"
							alt="CI/CD Diagram test step"
						/>
						<p>But let‚Äôs zoom in a bit.</p>
						<h3>Types of Tests</h3>
						<img
							src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/dat2-software-vs-doc-testing.png?w=1024"
							alt="Types of tests"
						/>
						<blockquote>
							<em
								>A word of caution: this diagram is by no means a complete
								picture of all types of testing (especially on the software
								development side). Also, if you think about it too much you‚Äôll
								see there‚Äôs a bit of an apples to oranges comparison going
								on</em
							>
							üòÖ
						</blockquote>
						<p>
							It seems fair to say that software testing is more mature as a
							discipline than Docs as Tests‚Äîafter all, it has been around for
							much longer. This is reflected in the diagram above where I show
							the various flavors of software testing.
						</p>
						<p>
							But Docs as Tests is catching up fast! When you look at the Venn
							diagram in the Docs section of the diagram, do you see anything
							familiar? You might recall (or not, which is fine!) how in the
							last post I shared
							<a href="./docs-as-tests-on-a-high-level#the-goods"
								>an image listing some of the tools</a
							>
							we have available for testing various parts of our docs.
						</p>
						<p>
							Below is that image [slightly altered for correctness/emphasis]
							again. The takeaway here is that despite Docs As Tests being the
							new kid (compared to software testing), we already have lots of
							tools we can use for our tests!
						</p>
						<img
							src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/dat2-testing-tools-v2.png?w=1024"
							alt="Testing areas"
						/>
					</section>
					<section>
						<h2 id="prerequisites">Prerequisites</h2>
						<blockquote>
							<em
								><p>
									You can‚Äôt save the world without the right tools, especially a
									crowbar.
								</p>
								<p>‚ÄîGordon Freeman (probably)</p></em
							>
						</blockquote>
						<p>
							I am going to list the tools that you‚Äôll need and where to get
							them. I believe they are all available in Windows, Mac, and Linux
							environments, but
							<a href="mailto:james.tasse@gmail.com">let me know</a> if you run
							into issues and we‚Äôll figure something out.
						</p>
						<p>
							Also, I know that people might prefer different tools. For
							example, the newer Cursor
							<a href="IDE"
								>https://en.wikipedia.org/wiki/Integrated_development_environment</a
							>
							has gained some popularity. Of course, if you are using a
							different IDE than VS Code, I suspect you already have the tools
							listed below (or equivalent) installed and can skip down to
							cloning my repo üòä
						</p>
						<p>OK, let‚Äôs get started.</p>
						<h3>Tools</h3>

						<ul>
							<li>
								Download and install
								<a href="https://git-scm.com/downloads">Git</a>
								<blockquote>
									Don‚Äôt be intimidated by the Git installer: it has many screens
									with different options (or at least the Windows one does), but
									the defaults ought to be fine in most cases. As all good
									defaults should be!
								</blockquote>
							</li>
							<li>
								Download and install
								<a href="https://code.visualstudio.com/download"
									>VS Code (or your preferred IDE)</a
								>
							</li>
							<li>
								Download and install
								<a href="https://nodejs.org/en/download">Node.js</a>
								<blockquote>
									I can vouch for Node.js major version 22 working fine with the
									tools we will use in these tests, but thankfully you can
									install multiple versions of Node if you need to use an older
									version for some reason.
								</blockquote>
							</li>
						</ul>

						<h3>Code</h3>
						<p>
							<em
								>In this section, we're going to
								<a href="https://git-scm.com/docs/git-clone">clone</a> the
								<a href="https://github.com/jtasse/docsastests-demo"
									>docsastests-demo</a
								>
								repository.
							</em>
						</p>
						<ul>
							<li>
								Open up a terminal. (I recommend Git Bash but other terminals
								like PowerShell work, too).
							</li>
							<li>
								Navigate to the directory where you want to store the code
								repository (note that this is totally arbitrary). I believe
								there are some slight differences in syntax depending on the OS
								and/or terminal, but let‚Äôs suppose you keep (or want to keep)
								your git projects within the <code>C:\git</code> directory. In
								this case you would run the command:
								<pre><code>cd C:\git</code></pre>
							</li>
							<li>
								You‚Äôll know you‚Äôre in the right place if you see something like
								following left of the blinking cursor in the terminal:
								<pre><code>C:\git></code></pre>
							</li>
							<li>
								OK, now go ahead and copy the following command and run it in
								your terminal:
								<pre><code>git clone https://github.com/jtasse/docsastests-demo.git</code></pre>
							</li>
							<li>
								You should see <code>Cloning into 'docsastests-demo'‚Ä¶</code> and
								some other messages appear in your terminal. If there are no
								errors, you can move on to installing dependencies.
							</li>
						</ul>
						<h2>Dependencies</h2>
						<blockquote>
							Dependencies are software (often referred to as packages) that we
							can include in a project if we don‚Äôt want to write the code for
							the corresponding functions ourselves. For example, since I do not
							want to write a tool that can auto-detect assertions in markdown
							and test them, we are going to install Doc Detective as a
							dependency.
						</blockquote>
						<p>
							One nice thing about dependencies is that it is generally quite
							easy to install them once they are defined in your project.
						</p>
						<blockquote>
							<strong>Further reading</strong>: if you‚Äôd like to see the
							dependencies for the docsastests-demo repo (or any other
							node-based project), open the package.json file at the root of the
							repo.
						</blockquote>
						<ul>
							<li>
								OK, now open a terminal (or use an existing one) and navigate to
								the root of the now-cloned <code>docsastests-demo</code> repo.
								For example, if you put it in the location I used above, the
								command would be:
								<pre><code>cd C:\git\docsastests-demo</code></pre>
							</li>
							<blockquote>
								<strong>Tip</strong>: modern IDEs like VS Code tend to have
								built-in terminal functionality. Although it‚Äôs not required to
								use it, you might find that it cuts down on context-switching
								and helps you ensure you are in the right place (when running
								commands that are directory-sensitive)
							</blockquote>
							<li>
								Now run the following command:
								<pre><code>npm install</code></pre>
							</li>
							<li>
								You should see some activity in your terminal. This command can
								take a long time to run in bigger projects, but we only have a
								few packages so it shouldn‚Äôt take more than a couple minutes.
							</li>
							<blockquote>
								<p>
									<strong>NOTE</strong>: after the package install is complete
									you might see a message in your output that looks like this:
								</p>
								<code> 19 vulnerabilities (6 moderate, 13 high) </code>
								<p>
									Unless you plan on creating and releasing production software
									from your current project/code, these vulnerabilities won‚Äôt
									affect you. üëπ
								</p>
							</blockquote>
						</ul>
						<h2>Structure of the docsastests-demo project</h2>
						<p>
							We‚Äôve installed all the stuff! However, before we jump into
							testing a quick tour of the project is in order.
						</p>
						<p>
							You can think of <code>docsastests-demo</code> as a Frankenstein
							application that has one purpose‚Äîhelping you learning how Docs as
							Test-ing (ugh, I know) works. After you go through the demo you
							are free to copy it, extend it, or delete it as you see fit. But
							for now, here‚Äôs a reference image and corresponding docs for how
							things are laid out:
						</p>
						<blockquote>
							<strong>NOTE</strong>: the content of this project workspace
							screenshot will become out of date almost immediately, as some
							folders (like the test results) will update with every test.
							However, I will try not to change the structure of the project
							more than is necessary
						</blockquote>
						<img
							src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/project-structure.png"
							alt="Docs as Tests demo project structure"
						/>
						<ol>
							<li>
								<strong>product</strong>: folder containing the files for the
								web application we are testing
							</li>
							<li>
								<strong>readthedocs</strong>: folder containing our Read the
								Docs implementation
							</li>
							<li>
								<strong>source</strong>: this is the folder where I am storing
								markdown files to be tested (we will use the highlighted
								account-setup.md file for our first test)
							</li>
							<li>
								<strong>results</strong>: this is the folder where Doc Detective
								will store test results (you can change this in
								.doc-detective.json)
							</li>
							<li>
								<strong>.markdown-doctest-setup.js</strong>: contains required
								setup code for markdown-doctest.
							</li>
							<li>
								<strong>.doc-detective.json</strong>: the configuration file for
								Doc Detective (see the Doc Detective config docs for more info)
							</li>
							<li>
								<strong>package.json</strong>: this file manages packages for
								the project (see the npm docs for more info)
							</li>
						</ol>
					</section>
					<section>
						<h2 id="running-the-tests">Running the tests</h2>
						<h3>
							UI Test (<a href="https://doc-detective.com/">Doc Detective</a>)
						</h3>
						<blockquote>
							In this test we're going to use Doc Detective to run the test
							described in the
							<a
								href="https://jamestasse.tech/old/2025/05/29/docs-as-tests-on-a-high-level/#demo"
								>demo</a
							>
							portion of the
							<a
								href="https://jamestasse.tech/blog/posts/docs-as-tests-on-a-high-level"
								>previous blog post</a
							>. After confirming that the test fails, we're going to make the
							required change in our docs and run the tests again to verify the
							issue is resolved.
						</blockquote>
						<ul>
							<li>
								Begin by opening the account-setup.md file, which lives at the
								path <code>readthedocs/docs/source/account-setup.md</code>.
								(This file is also highlighted in my workspace screenshot
								above).
							</li>
							<blockquote>
								<strong>NOTE</strong>: paths can be a bit confusing depending on
								the use case, but I usually mean ‚Äúpath if starting from the
								workspace root‚Äù. If I mean something else, I will try to call it
								out.
							</blockquote>
							<li>
								OK, so you should see markdown match what I have here:
								<img
									src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/dat2-account-setup-md.png"
									alt="account setup docs"
								/>
							</li>
							<blockquote>
								<strong>NOTE</strong>: you can optionally view Doc Detective
								tests before they run using the
								<a
									href="https://marketplace.visualstudio.com/items?itemName=DocDetective.doc-detective"
									>Doc Detective extension</a
								>
								for VS Code
							</blockquote>

							<li>
								Before we can test our docs against our product, we need to
								bring the product page (located at
								<code>product/index.html</code>) online. To do this, open a
								terminal and run the command:
								<pre><code>node server.js</code></pre>
							</li>
							<li>
								You should get a confirmation in the terminal that the server is
								running:
								<img
									src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/dat2-server-running.png"
									alt="Node server running"
								/>
							</li>
							<blockquote>
								<strong>NOTE about terminals</strong>: when you run a process
								like a Node server in a terminal, the process essentially takes
								that terminal over. So if you want to run other commands without
								interrupting the server, you need a new terminal instance.
							</blockquote>
							<li>First, open a new terminal instance.</li>
							<li>
								Now, from the new terminal (not the one running the Node
								server), execute the following command:
								<pre><code>npx doc-detective --input readthedocs/docs/source/account-setup.md</code></pre>
							</li>
							<blockquote>
								<strong>NOTE</strong>: <code>npx</code> is a Node command that
								lets you run‚Ä¶other commands. Further reading in the
								<a href="https://docs.npmjs.com/cli/v8/commands/npx">npm docs</a
								>.
							</blockquote>
							<li>
								This test might take a couple minutes, and you‚Äôll see a lot of
								activity in the terminal. Keep waiting until you see the
								following:
								<img
									src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/initial_test_results.png"
									alt="initial test results"
								/>
								<ol>
									<li>
										Indicates where the test results for this run have been
										saved.
									</li>
									<li>
										Shows that the terminal is ready to accept new commands.
									</li>
								</ol>
							</li>
							<li>
								At this point we <em>could</em> just scroll up in the terminal
								to see the test results, but because of all the output in the
								terminal I find it‚Äôs easy to get lost there. Instead, let‚Äôs go
								ahead and open the results file directly.
								<img
									src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/test-results-file.png"
									alt="test results file"
								/>
								<blockquote>
									<strong>Tip</strong>: even within the results file, there is
									still a lot of content! To jump to the results we care about
									the most, do a find (<code>Ctrl + F</code>) in the file and
									search for:
									<pre><code>"steps": [</code></pre>
								</blockquote>
							</li>
						</ul>

						<h2 id="reviewing-test-results">Reviewing Test Results</h2>
						<p>
							<em
								>OK, we made it to our test results! But rather than relying on
								screenshots, let‚Äôs review each JSON result one block at a
								time‚Ä¶</em
							>
						</p>
						<blockquote>
							<strong>NOTE</strong>: if you see any discrepancies in your test
							results compared to mine, feel free to reach out to me.
						</blockquote>
						<img
							src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/test-results-screenshot-steps.png"
							alt="test results file - steps"
						/>
						<blockquote>
							<strong>NOTE</strong>: if you installed the optional
							<a
								href="https://marketplace.visualstudio.com/items?itemName=DocDetective.doc-detective"
								>Doc Detective extension</a
							>
							in VS Code, the structure of these results should look familiar
						</blockquote>
						<ul>
							<li>
								Let‚Äôs start with the first block:
								<pre><code>
{
"result": "PASS",
"resultDescription": "Opened URL.",
"goTo": {
	"url": "http://localhost:3000/"
},
"stepId": "67f92b95-bae1-4c15-b9b8-4d5f3c4030b6"
}
								</code></pre>
							</li>
							<li>
								Nice! With this test, Doc Detective:
								<ol>
									<li>
										Saw the URL in the first step of our account-setup.md file
									</li>
									<li>Attempted to access the URL and succeeded</li>
									<li>Reported a ‚ÄúPASS‚Äù result for this test</li>
								</ol>
							</li>
							<li>
								Let‚Äôs look at the next test:
								<pre><code>
{
"result": "PASS",
"resultDescription": "Returned 200",
"checkLink": {
"url": "http://localhost:3000/"
},
"stepId": "9681b914-1cb4-42d2-8e9e-0af1d21602f6"
}
</code></pre>
							</li>
							<li>
								<p>
									If you‚Äôre not familiar with
									<a
										href="https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Status"
										>HTTP response codes</a
									>, a <code>200</code> means that the request has succeeded. To
									me, the previous test result (i.e. ‚Äì successful navigation to
									a web page) seemingly renders this test unnecessary; but there
									could be a reason Doc Detective runs this test separately, and
									it is definitely not doing any harm!
								</p>
							</li>
							<li>
								<p>Next!</p>
								<pre><code>
{
	"outputs": {
	"element": {
	"text": "Email"
}
},
	"result": "PASS",
	"resultDescription": "Found an element matching selector. Found element by text.",
	"find": "Email",
	"stepId": "79fe9fb3-0843-4711-94fa-bc757493c9e5"
}
								</code></pre>
								<p>
									This is an example of Doc Detective being quite clever. Here‚Äôs
									what it did:
								</p>
								<blockquote>
									Let‚Äôs start using DD as shorthand for Doc Detective, which
									delivers (at least) a double-dose of testin‚Äô
								</blockquote>
								<ol>
									<li>
										DD saw that email in account-setup.md was wrapped in
										double-asterisks (so **Email**).
									</li>
									<li>
										DD does not think (as far as I know?), but if it did, it
										made a note of the above and thought ‚ÄúI‚Äôm going to go and
										look for an email field on the product page‚Äù mentioned in
										step 1.
									</li>
									<li>
										DD determined that the product page *indeed contained an
										email field, and reported that it ‚ÄúFound an element matching
										selector‚Äù (i.e. ‚Äì Email)
									</li>
									<li>Recorded a PASS result for this test</li>
								</ol>
								<blockquote style="color: yellow">
									*<strong>CAUTION</strong>: I wanted to call out here that Doc
									Detective appears to require a field label (in this case,
									<label for="email">Email</label>) in order to pick up Email or
									other fields. If you are testing a web application and its
									syntax does not align with this approach then you might not be
									able to use DD autodetect in the relevant areas.
								</blockquote>
							</li>
							<li>
								Next test.
								<pre><code>
									{
"outputs": {
	"element": {
		"text": "New Password"
	}
	},
	"result": "PASS",
	"resultDescription": "Found an element matching selector. Found element by text.",
	"find": "New Password",
	"stepId": "7b331142-38da-46f3-b9ef-feef72202593"
                }
								</code></pre>
								<p>
									This test was very similar to the test for the Email field,
									with DD looking for a New Password field instead. It passed
									once DD found the following label in index.html:
									<label for="password">New Password</label>
								</p>
							</li>
							<li>
								All right, we‚Äôve made it to the last test of this particular
								demo!
								<pre><code>
{
	"result": "FAIL",
	"resultDescription": "No elements matched selector or text.",
	"click": "Create Account",
	"stepId": "d942f059-bb0c-4f6a-862f-d948d976538c"
},
</code></pre>
								<p>
									In this test, DD searched for an element with the text ‚ÄúCreate
									Account‚Äù, but couldn‚Äôt find it. So the test failed.
								</p>
								<p>
									In a real world example, this might manifest as the
									Development/Engineering team changing the text of a button
									without informing the Docs team that the corresponding
									documentation needed to be updated. But we have tests now, and
									we just caught it before the release! ü•≥
								</p>
								<blockquote>
									<strong>NOTE</strong>: I do see another
									<em>"Create Account not found"</em> failed test that appears
									identical to the one above. I am not sure why there is another
									one, but I am going to ignore it for now and move on.
								</blockquote>
							</li>
						</ul>
					</section>
					<section>
						<h2 id="making-and-verifying-the-fix">
							Making &amp; Verifying the Fix
						</h2>
						<p>
							OK, so Doc Detective found a discrepancy between the docs and the
							product. Awesome! But what happens next?
						</p>
						<p>
							While it‚Äôs possible that the change in the product was a mistake,
							it‚Äôs probably more likely that the Product team wanted to change
							the button language to what it is now (i.e. ‚Äì Sign Up instead of
							Create Account) and they just forgot to tell the Docs team. (I
							mean hopefully they forgot and it‚Äôs no all out war between
							departments! üí•).
						</p>
						<p>
							Accordingly, it would probably be a good idea for your Docs team
							to reach out to Product to confirm that this was indeed a
							misunderstanding. Let‚Äôs assume that it was, in which case there is
							no further action required by the Product or Engineering teams for
							this particular case.
						</p>
						<blockquote>
							Obviously if the Docs team is implementing Docs as Tests, at some
							point one would expect a dialogue between the Docs team and
							Product, Engineering, etc. That is outside the scope of this
							(already long) post, but Manny Silva‚Äôs
							<a
								href="https://www.amazon.com/Docs-Tests-Resilient-Technical-Documentation-ebook/dp/B0F1H97QSL/ref=tmm_kin_swatch_0"
								>Docs as Tests</a
							>
							book does a good job addressing it!
						</blockquote>
						<p>
							But now that we know what the ‚Äúblessed‚Äù language from Product
							looks like, let‚Äôs go ahead and update our docs.
						</p>

						<ul>
							<li>
								First, open readthedocs/docs/source/account-setup.md in your
								IDE.
							</li>
							<li>
								Now, on line 6 where it reads:
								<code>4. Click **Create Account**</code>‚Ä¶
								<img
									src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/create-account-before.png"
									alt="create account - before"
								/>
							</li>
							<li>
								‚Ä¶change it so it reads <code>4. Click **Sign Up**</code>. (Be
								sure to save your changes).
								<img
									src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/create-account-after.png"
									alt="create account - after"
								/>
							</li>
							<li>
								Now go ahead and run your tests again:
								<pre><code>
npx doc-detective --input readthedocs/docs/source/account-setup.md
								</code></pre>
								<img
									src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/dat2-tests-passing.png"
									alt="all items passed"
								/>
							</li>
							<li>
								But just to be sure, let‚Äôs take a look at the formerly failing
								test which is now passing:
								<pre><code>
{
	"outputs": {
	"element": {
		"text": "Sign Up"
	}
	},
	"result": "PASS",
	"resultDescription": "Found an element matching selector. Found element by text.",
	"find": "Sign Up",
	"stepId": "933314a7-0851-4319-ad00-355b024f9390"
}
								</code></pre>
							</li>
							<li>
								Bravo‚Äîyou just resolved a discrepancy between the docs and the
								product before it ever got out the door! ü•≥
							</li>
						</ul>
					</section>
					<section>
						<h2 id="api-test">
							API Test (<a href="https://github.com/Widdershin/markdown-doctest"
								>markdown-doctest</a
							>)
						</h2>
						<p>
							Up until now, our testing has been all about the UI. But I wanted
							to conclude this post by dipping into another area, and why not
							API testing?
						</p>
						<blockquote>
							In this test we‚Äôll use markdown-doctest to find an issue with one
							of our code snippets. As with our previous test, we‚Äôll fix the
							issue (this time in our code snippet) and verify our test passes.
						</blockquote>
						<ul>
							<li>
								All right, since we don‚Äôt need a local web server for this test,
								you can (optionally) stop the Node server you ran in the
								previous test by opening the terminal where it‚Äôs running and
								pressing <code>CTRL + C</code>.
							</li>
							<li>
								Now go ahead and open the file
								<code>readthedocs/docs/source/js.md</code> in your IDE.
								<img
									src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/calling-placeholder-api.png"
									alt="calling placeholder API"
								/>
								<ol>
									<li>
										Remember that this is a markdown file (even though it is
										comprised mostly of JavaScript)
									</li>
									<li>
										In markdown, 3 backticks (‚Äò`‚Äô) followed by a language
										identifier begins a code block (or code snippet).
									</li>
									<li>
										This is the most important line for our testing. Keep an eye
										on that URL üßê
									</li>
									<li>
										Cool. We already did our setup earlier, so let‚Äôs go ahead
										and run the test!
									</li>
								</ol>
								<pre><code>
npx markdown-doctest
								</code></pre>
							</li>
							<li>
								The output here is a bit misleading on account of some
								combination of A) the JavaScript I told Copilot to write for our
								snippet and B) the expected usage for markdown-doctest. üòè But
								that‚Äôs OK, as we can still get a meaningful result. As I‚Äôve
								highlighted below, the test reported that it encountered an HTTP
								response code of <code>404</code> (not found) when trying to do
								a fetch from the endpoint at
								<code>https://jsonplaceholder.typicode.com/todoz/1</code>.
								<img
									src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/dat2-404-error.png"
									alt="404 not found result"
								/>
							</li>
							<li>
								Wait a minute, what‚Äôs a TODOz list? üòÅ Let‚Äôs go back to our
								<code>readthedocs/docs/source/js.md</code> file and fix the code
								snippet.
							</li>
							<li>
								Change the URL on line 7 from
								<code>https://jsonplaceholder.typicode.com/todoz/1</code> to
								<code>https://jsonplaceholder.typicode.com/todos/1</code> and
								save your changes.
							</li>
							<li>
								Your js.md file should now look like this:
								<img
									src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/fixed-api-response.png"
									alt="Fixed API response"
								/>
							</li>
							<li>
								Now run the test again:
								<pre><code>
npx markdown-doctest
								</code></pre>
								<img
									src="/src/content/blog/posts/docs-as-tests-part-ii-the-how/images/dat2-doctest-passed.png"
									alt="markdown-doctest passing"
								/>
							</li>
							<p>
								Look, no 404! Essentially, we just verified that after fixing a
								typo in one of our code snippets, the test suite is now able to
								reach the correct endpoint without errors. And because we caught
								it before the docs were released, we didn‚Äôt have to hear about
								the developers who called Support asking why their TODOz apps
								weren‚Äôt working. üòÇ
							</p>
							<p>Great job! üëç</p>
						</ul>
					</section>
					<section>
						<h2 id="what-now">What now?</h2>
						<p>
							Since you‚Äôve now tested a UI and API using different tools, you
							can officially say you have Docs as Tests experience in those
							areas üòé And seriously, give yourself credit for all of the work
							it took to get here. Last I checked, the widget that indicates
							‚Äúreading time‚Äù for this post was at 20 minutes, but I suspect it
							took you at least 2-3 times make it through all of that setup and
							testing (probably more for the less technical folks ü´°).
						</p>
						<p>
							But obviously it doesn‚Äôt end here. For my part, I‚Äôm going to move
							on to making a video that covers this and the last post. I know
							some people vibe with learning from videos more than reading, and
							I also have a large video-shaped hole in my portfolio ü´§
						</p>
						<h2 id="code-coverage">Code Coverage</h2>
						<p>
							After that, there is a topic that I think deserves some attention:
							code coverage. You‚Äôve probably noticed that I have a strong
							preference for running tests that are auto-detected using tools
							like Doc Detective. Aside from the fact that these tests have high
							return on investment, they also scale with your docs
							automatically.
						</p>
						<p>
							However, if code coverage of documentation-based tests is taken
							into account, it becomes easier for us to have confidence that we
							are ‚Äúcovering‚Äù all of our products with these tests. And,
							crucially, this can help us prevent our hand-crafted tests from
							becoming out of sync with our docs.
						</p>
						<p>
							That‚Äôs it for now. Follow me on LinkedIn if you‚Äôd like to be
							notified when I publish a video or another blog post.
						</p>
						<p>Cheers.</p>
					</section>
				</article>
			</main>
		</div>
	</body>
</html>
